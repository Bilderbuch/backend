# Шаблонизатор Razor

В этом задании предстоит внедрить ASP.NET Core MVC с шаблонизатором Razor в существующий новостной проект,
расширить его функционал, настроить чтение конфигурации, обработку и логирование ошибок.


## 0. Исследование приложения

Запусти приложение и убедись, что открылся сайт новостей.
Попробую перейти на следующую страницу списка, зайди в любую из новостей.

Посмотри как эти страницы формируются в `Startup.cs`.
Для правильной адресации используются методы `Map` и `MapWhen`,
а ответы формируются в методах `RenderIndexPage` и `RenderFullArticlePage`.

Полезно понять, как это работает, но детали можно не запоминать — этот код предстоит отрефакторить.


## 1. Обработка ошибок и логирование

Хорошо, когда приложение работает правильно. Но наивно полагать, что ошибки не будут возникать.
Игнорировать ошибки — значит поступать безответственно, заставлять пользователей страдать.
Правильная стратегия — обрабатывать ошибки так, чтобы о них как можно быстрее узнать и решить проблему.


### 1.1. Страница для кода состояния

Для начала открой сайт новостей и попробуй перейти по пути `/somepath` в рамках сайта.
Ты должен увидеть страницу с 404 ошибкой, только не от сайта новостей, а от браузера.

Это неплохо, но правильный подход — не надеяться на браузер пользователя, а показать специальную страницу ошибки.
На ней понятно объяснить, что произошла ошибка, а также предложить дальнейшие действия для исправления ситуации.
Например, можно предложить вернуться на главную, или предложить обновить страницу
или обратиться в техподдержку указанным способом.


В ASP.NET Core для этого достаточно добавить соответствующий middleware для редиректа пользователя по адресу,
на котором находится специальная страница с описанием ошибки:
```cs
app.UseStatusCodePagesWithReExecute("/Errors/StatusCode/{0}");
```
А также разместить по этому адресу страницу.
Страница пока подождет, а прямо сейчас добавь `UseStatusCodePagesWithReExecute`
сразу после `UseStaticFiles` и перед первым `app.Map`.


В перспективе хочется перевести весь сайт новостей на ASP.NET Core MVC,
поэтому стоит подключить MVC уже сейчас и разрабатывать весь новый функционал с его использованием.

Для этого надо добавить куда-нибудь в конфигурацию контейнера контроллеры с представлениями:
```cs
services.AddControllersWithViews();
```

А в конфигурацию последовательности обработки запроса добавить такие middleware после подключения всех остальных:
```cs
app.UseRouting();
app.UseEndpoints(endpoints =>
{
	endpoints.MapControllerRoute("status-code", "Errors/StatusCode/{code?}", new
	{
		controller = "Errors",
		action = "StatusCode"
	});
});
```
Они подключают обработку путей с помощью MVC и конкретно в данной конфигурации написано очень четко,
что ровно один тип путей должен обрабатываться методом `StatusCode` контроллера `ErrorsController`.
Причем этому методу будет передаваться параметр `code`.


**Дополнительные пояснения про `UseRouting` и `UseEndpoints`**
`UseRouting` отмечает тот момент обработки запроса, когда запросу сопоставляется его обработчик в MVC.
Например, конкретный метод контроллера, который будет его обрабатывать. Этот обработчик в MVC называется endpoint.
`UseEndpoints` отмечает тот момент обработки запроса, когда вызывается сопоставленный запросу endpoint.
Не должно смущать, что конфигурируются `endpoints` при вызове `UseEndpoints`.
На самом деле эта конфигурация становится общей и при обработке запроса используется
и в `UseRouting` middleware, и в `UseEndpoints` middleware.
А само разделение функционала на два «промежуточных слоя» было сделано для того, чтобы в момент,
когда уже известно как будет обрабатываться запрос, но обработка еще не произошла,
можно было встроить еще какой-нибудь middleware. Например, промежуточный слой для авторизации:
```cs
app.UseRouting();
app.UseAuthorization();
app.UseEndpoints(endpoints => { ... });
```


Итак, осталось добавить контроллер `ErrorsController` с методом `StatusCode`.
Для этого создай папку `Controllers` и создай в ней файл `ErrorsController` с таким содержимым:
```cs
using Microsoft.AspNetCore.Mvc;

namespace BadNews
{
    public class ErrorsController : Controller
    {
        public IActionResult StatusCode(int? code)
        {
            return View(code);
        }
    }
}
```
Обрати внимание, что в качестве модели в представление передается код ошибки,
ведь иначе предсталение не сможет этот код ошибки отобразить.

А также добавить представление, которое и сформирует страницу.
Раз контроллер называется `Errors`, а метод `StatusCode`, то представление для него MVC
будет искать по пути `/Views/Erros/StatusCode.cshtml`, либо `/Views/Shared/StatusCode.cshtml`.
Пояснение: В папке `/Views/Shared` можно хранить представления, которые используются в нескольких контроллерах.
Создай файл `/Views/Erros/StatusCode.cshtml`, а содержимое для него возьми в заготовке `/$Content/Drafts/StatusCode.cshtml`.


Снова попробуй перейти по пути `/somepath` в рамках сайта. Теперь должна отобразиться красивая страница с кодом ошибки.


### 1.2. Страница для исключений

Следующий тип ошибок, который должен корректно обрабатываться — непредвиденные, исключительные ошибки.
В смысле, исключения.

Открой сайт новостей и перейди на любую новость.
В адресной строке ты увидешь путь вида `/news/fullarticle/5ab19137-3e28-4eca-bd19-3185ebeba0c6`.
В конце пути идет идентификатор новости. Поменяй в нем что-нибудь, можно даже так: `/news/fullarticle/123`.
В результате ты увидишь страницу, которая рассказывает о том, что произошло исключение, и рассказывает подробности.
Эта страница генерируется с помощью промежуточного слоя `UseDeveloperExceptionPage`.

Это очень удобно для разработки. А вот сайт в продакшене не должен показывать всем подряд столько информации,
ведь это может упростить атаку на вашу разработку. Пользователю надо показывать менее информативную страницу.


Действия аналогичны добавлению страницы для кода статуса:
1. Закомментируй строчку `app.UseDeveloperExceptionPage();`
и после нее добавь `app.UseExceptionHandler("/Errors/Exception");`.
2. Добавь метод `Exception` в `ErrorsController`, аналогичный `StatusCode`, но без параметров.
Метод `View` вызови так: `View(null, HttpContext.TraceIdentifier)`.
В качестве `viewName` передается `null`, а значит будет искаться представление, соответствующее имени метода.
В качестве `model` здесь передается `HttpContext.TraceIdentifier`, как и задумано.
Вариант `View(HttpContext.TraceIdentifier)` здесь работать не будет. Сам подумай почему.
3. Добавь новое представление `Exception.cshtml` в папку `/Views/Errors`. 
Содержимое для него возьми в заготовке `/$Content/Drafts/Exception.cshtml`.
4. Добавь дополнительную конфигурацию в `UseEndpoints`, на этот раз более универсальную,
подходящую для разных контроллеров и методов в них:
`endpoints.MapControllerRoute("default", "{controller}/{action}");`

Убедись, что после проделанных действий по пути `/news/fullarticle/123` открывается заготовленная страница.


Все же это довольно удобно, когда при разработке выводится подробная информация об исключениях.
Информацию о том, в какой среде выполняется приложение ASP.NET Core можно с помощью объекта `IWebHostEnvironment`.
Поэтому правильная настройка страницы для исключений выглядит так:
```cs
if (env.IsDevelopment())
    app.UseDeveloperExceptionPage();
else
    app.UseExceptionHandler("/Errors/Exception");
```
Используй ее и перезапусти приложение.

Снова перейди по пути `/news/fullarticle/123`. Ты должен снова увидеть страницу с подробной информацией об исключении.

Как же теперь проверить, что в production все будет правильно работать? Надо задать окружение вручную!
В ASP.NET Core среда задается переменной окружения `ASPNETCORE_ENVIRONMENT`.
В проекте переменные окружения можно задать в файле `/Properties/launchSettings.json`.
Причем значения переменных, заданные в файле `launchSettings.json`, переопределяют значения, заданные в системе.
Таким образом, чтобы посмотреть как все будет выглядеть в production, найди файл `/Properties/launchSettings.json`
и задай для `ASPNETCORE_ENVIRONMENT` значение `Production`.

Перезапусти приложение и проверь, что для пути `/news/fullarticle/123` снова отдается страница с минимумом информации об исключении.

Еще один способ задать среду — задать ее через код. Поменяй параметр вызова `ConfigureWebHostDefaults` вот так:
```cs
ConfigureWebHostDefaults(webBuilder =>
{
    webBuilder.UseStartup<Startup>();
	webBuilder.UseEnvironment(Microsoft.Extensions.Hosting.Environments.Development);
})
```

Перезапусти приложение и проверь, что для пути `/news/fullarticle/123` отдается страница с подробной информацией об исключении.

Среда разработки `Development` подходит, поэтому можно больше ничего не менять.
В реальном приложении, конечно, среда должна управляться настройками и для реальных пользователей должен быть `Production`.


### 1.3. Логирование

Ошибки важно не только показывать, но и сохранять для дальнейшего исправления.

Система логирования уже встроена в ASP.NET Core и многие компоненты благодаря этому сразу умеют писать логи.
Другой вопрос — куда сообщения от системы логирования попадут.
Тут есть простор для выбора, благо встроенная система логирования легко расширяется.

Расширить можно с помощью библиотеки Serilog.
Serilog может генерировать сообщения в обычном формате человекочитаемых строчек,
но также поддерживает так называемое «структурное логирование», т.е. может генерировать сообщения в виде JSON.
Сообщения в виде JSON легче обрабатывать автоматически, а еще можно сразу отправлять в сервис для сбора логов.
Писать Serilog умеет и в консоль, и в файлы, и в удаленные сервисы для сбора логов,
а еще можно написать своего «потребителя логов», в который Serilog будет писать.

**Дополнительные пояснения про структурное логирование**
Структурное логирование и централизованное хранение логов в специальном сервисе — это современный тренд.
Это позволяет разработчикам в одном месте искать логи последних событий при разборе обращений от пользователей
и других проблем в сервисе. Но для того, чтобы работал поиск, надо ключевые значения из сообщения логов вычленить.
И в этом случае удобнее сохранять сообщения сразу в виде JSON, в полях которого записывать необходимые ключевые значения.


Пришло время добавить логирование.
1. NuGet-пакет Serilog уже подключен к проекту — ура!
2. Подключи Serilog к хосту, чтобы использовался он, а не реализация логирования от Microsoft.
Для этого обнови метод `CreateHostBuilder` в `Program.cs`:
```cs
public static IHostBuilder CreateHostBuilder(string[] args)
{
    return Host.CreateDefaultBuilder(args)
	    .ConfigureWebHostDefaults(webBuilder =>
	    {
            ...
        })
        .UseSerilog((hostingContext, loggerConfiguration) =>
            loggerConfiguration.ReadFrom.Configuration(hostingContext.Configuration));
}
```
Serilog можно конфигурировать через код, но здесь для конфигурации используется `IConfiguration` хоста,
которая собирается стандартным образом.
3. Положи настройки логирования в файл `appsettings.json`, раз уж настроил, что они берутся из `IConfiguration`.
Настройки обычного логирования от Microsoft при этом можно удалить:
```json
{
  "Serilog": {
    "WriteTo": [
      {
        "Name": "File",
        "Args": {
          "path": ".logs/log-.txt",
          "formatter": "Serilog.Formatting.Compact.RenderedCompactJsonFormatter, Serilog.Formatting.Compact",
          "rollingInterval": "Day",
          "rollOnFileSizeLimit": true
        }
      },
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}"
        }
      }
	],
	"MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    }
  },
  "AllowedHosts": "*"
}
```
4. Обрати внимание на конфигурацию. В ней настроен `rollingInterval` и `rollOnFileSizeLimit`.
В реальных приложениях за день могут накопиться сотни мегабайт логов, если не больше.
Крупными файлами неудобно манипулировать, поэтому лучше логи разбивать по датам, а еще и по размеру,
если почему-то логов за день слишком много.
5. Перейди по пути `/news/fullarticle/123`, чтобы получить исключение.
Убедись, что оно было залогировано в файле `/.logs/log-{current-date}` в виде JSON.


Кроме ошибок полезно логировать вообще все запросы. Как минимум, это помогает понять последовательноть
действий пользователя, которые к ошибке привели. С Serilog это элементарно — достаточно добавить промежуточный слой!
Добавь строчку `app.UseSerilogRequestLogging();` сразу после промежуточного слоя статических файлов,
т.к. информация об обращении к статике не особо интересна.

Сделай несколько запросов и убедись, что они залогировались в виде JSON файлах,
а также в читабельном виде попали в отладочную консоль. Примерно в таком виде:
`[14:12:26 INF] HTTP GET / responded 200 in 58.2818 ms {"SourceContext": "Serilog.AspNetCore.RequestLoggingMiddleware"}`


А что произойдет, если конфигурация приложения будет испорчена?
Полностью удали содержимое файла `appsettings.Development.json`, ведь там осталась ненужная конфигурация
логирования от Microsoft. Сам файл оставь.

Теперь попробуй запустить приложение.

Вообще-то оно должно сразу упасть. А что же в логах? Ничего?
Относительно редкая ситуация, когда приложение даже не может стартануть,
но все равно было бы неплохо зафиксировать что-то в логах.
А значит логирование надо сконфигурировать хотя бы минимальным образом еще до чтения конфигурации.

Поменяй содержимое метода `Main` в `Program.cs`:
```cs
public static void Main(string[] args)
{
    InitializeDataBase();

    Log.Logger = new LoggerConfiguration()
        .WriteTo.File(".logs/start-host-log-.txt",
            rollingInterval: RollingInterval.Day,
            rollOnFileSizeLimit: true,
            outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}")
        .CreateLogger();

    try
    {
        Log.Information("Creating web host builder");
        var hostBuilder = CreateHostBuilder(args);
        Log.Information("Building web host");
        var host = hostBuilder.Build();
        Log.Information("Running web host");
        host.Run();
    }
    catch (Exception ex)
    {
        Log.Fatal(ex, "Host terminated unexpectedly");
    }
    finally
    {
        Log.CloseAndFlush();
    }
}
```
Теперь будет залогировано любое необработанное исключение, из-за которого упадет весь хост.
Но важно, что здесь до построения хоста добавляется логирование в `.logs/start-host-log-{current-date}.txt`.
Благодаря этому, если до обычного конфигурирования логирования произойдет исключение,
оно будет залогировано в `start-host-log`. При этом после успешной конфигурации логирования по `IConfiguration`,
`Logger` будет заменен на сконфигурированный.

Снова попробуй запустить приложение. После падения убедись, что появился файл `.logs/start-host-log-{current-date}.txt`,
в котором залогировано исключение.

Все же придется написать в `appsettings.Development.json` пустой объект `{}`, чтобы приложение перестало падать.


Базовый уровень логирования обеспечен. Но бывает нужно залогировать что-то дополнительно.
Добавь дополнительное логирование в метод `StatusCode` контроллера `ErrorsController`.
Для этого придется добавить конструктор и принять из контейнера `ILogger<>`:
```cs
private readonly ILogger<ErrorsController> logger;

public ErrorsController(ILogger<ErrorsController> logger)
{
    this.logger = logger;
}

public IActionResult StatusCode(int? code)
{
    logger.LogWarning("status-code {code} at {time}", code, DateTime.Now);
    return View(code);
}
```

Перейди по пути `/somepath`, дождись появления страницы с кодом 404.
Убедись, что в лог попало дополнительное сообщение про status-code.


## 3. Рефакторинг новостей

Пришло время перевести страницы новостей на MVC.


### 3.1. Новый список новостей

Для начала надо сделать так, чтобы по пути `/` отображался список новостей на MVC,
а по пути `/news` — старый. Это позволит их сравнивать.


Для начала закомментируй `app.MapWhen` в промежуточных слоях, чтобы запросы по пути `/` доходили до MVC.
А конфигурацию `default` в `UseEndpoints` поменяй на такую:
```cs
endpoints.MapControllerRoute("default", "{controller=News}/{action=Index}");
```
В такой конвеции заданы значения по умолчанию для контроллера и экшена, поэтому для пути `/` управление
будет передаваться в метод `Index` контроллера `News`.


Следующий шаг — создать контроллер `NewsController` с методом `Index` в папке `/Controllers`.
Используй вот эту «болванку» для начала:
```cs
using BadNews.ModelBuilders.News;
using Microsoft.AspNetCore.Mvc;

namespace BadNews
{
    public class NewsController : Controller
    {
        private readonly INewsModelBuilder newsModelBuilder;

        public NewsController(INewsModelBuilder newsModelBuilder)
        {
            this.newsModelBuilder = newsModelBuilder;
        }

        public IActionResult Index()
        {
            return View();
        }
    }
}
```
В ней учтен тот факт, что подготовкой данных для отображения в работающей сейчас реализации
занимается `INewsModelBuilder` и в новой должно быть также.


Теперь надо добавить представление. Оно должно оказаться в папке `/Views/News/Index.cshtml`.
Заполни этот файл из шаблона, который используется для отображения списка новостей сейчас.
Другими словами, скопируй в него содержимое из файла `/$Content/Templates/Index.hbs`.

Перейди по пути `/` и убедись, что какая-то кривая страничка с текстом `{{articles}}` отображается.
Значит в первом приближении контроллер работает.


Найди в `Startup.cs` метод `RenderIndexPage` и разберись как он работает.
Твоя задача, в целом, — повторить то, что он делает, только средствами MVC.

Теперь выполни конкретные шаги:
1. В методе `Index` контроллера `NewsController` добавь параметр `int pageIndex = 0` со значением по-умолчанию,
чтобы получить значение из query string.
2. В методе `Index` используй `newsModelBuilder`, чтобы построить модель страницы.
Передай эту модель во `View`.
3. В представлении `Index.cshtml` добавь первой строкой директиву,
описывающую тип модели `@model BadNews.Models.News.IndexModel`.
4. Место `{{articles}}` в представлении используется для того, чтобы отображать список новостей.
При этом используется шаблон `/$Content/Templates/NewsArticle.hbs`. Вставь этот шаблон вместо `{{articles}}`.
5. Оберни скопированный шаблон новости в цикл:
```cs
@foreach (var article in Model.PageArticles)
{
    /* шаблон новости */
}
```
6. Запусти приложение и открой страницы: убедись, что отображается 5 шаблонов новостей и нет ошибок.


В этот момент правки над контроллером закончены, а вот представление придется править много раз.
Чтобы не перезапускать каждый раз приложение можно добавить функционал,
который будет без остановки сервиса перестраивать и обновлять представления, если их код поменялся.
Конечно, делать это следует только в разработке.
Подключи этот функционал, заменив в `ConfigureServices` строчку `services.AddControllersWithViews();` на
```cs
var mvc = services.AddControllersWithViews();
if (env.IsDevelopment())
    mvc.AddRazorRuntimeCompilation();
```
Теперь можно просто обновить представление, а затем обновить страницу браузера, чтобы увидеть изменения.


Теперь можно аккуратно заполнить шаблон новости по модели.
Это означает, что надо заменить все `{{какое-то-имя}}` в шаблоне на значения из переменной `article`.
В качестве подсказки используй метод `BuildIndexPageHtml` в `Startup.cs`.

Вот какие при этом могут случиться нюансы:
- Чтобы отрендерить значение в Razor, перед ним надо поставить знак @:
```cs
@someValue
```
- Чтобы использовать переменную `culture`, определи ее в начале представления такими строчками:
```cs
@using System.Globalization
@{
    var culture = CultureInfo.CreateSpecificCulture("ru-ru");
}
```
- Когда захочется заменить `{{url}}`, то чтобы не запутаться в кавычках и скобочках,
стоит заменить `{{url}}` на `@url`, а переменную `url` определить в первой строке тела цикла.
Razor достаточно умен, чтобы понять, что это не тег, а значит это код на C#.
- Чтобы использовать `HttpUtility` добавь в начале представления строчку:
```cs
@using System.Web
```

Теперь список новостей должен выглядеть корректно, а ссылки «Читать полностью» должны работать.


Осталось сделать корректный переход по страницам. Для этого надо вычислить адреса для кнопок перехода по страницам.
Сделать это можно прямо в представлении, даже прямо в теге `<nav>`:
```cs
<nav class="news-pagination">
    @{
        var newerUrl = !Model.IsFirst
            ? $"/news?pageIndex={HttpUtility.UrlEncode((Model.PageIndex - 1).ToString())}"
            : "";
        var olderUrl = !Model.IsLast
            ? $"/news?pageIndex={HttpUtility.UrlEncode((Model.PageIndex + 1).ToString())}"
            : "";
    }

    <!-- разметка ссылок -->
</nav>
```
Определи `newerUrl` и `olderUrl` как показано и используй эти значения вместо `{{newerUrl}}` и `{{olderUrl}}`.
И проверь, что переходы по страницам работают.


Итак, страница списка новостей переделана и можно ее использовать и для адреса `/news`.
При этом вжно не сломать страницу новости, а значит `Map` надо переделать аккуратно. Вот так:
```cs
app.Map("/news/fullarticle", fullArticleApp =>
{
    fullArticleApp.Run(RenderFullArticlePage);
});
```
Другие использования `Map` можно удалить. И проверить, что сайт продолжает правильно работать!


### 3.2. Новая страница новости

Пришло время переделать страницу новости.

Алгоритм переделки повторяется:
1. Надо создать метод в контроллере для пути `/news/fullarticle`
2. Добавить в метод необходимый параметр `Guid id`, т.е. идентификатор новости
3. В метод использовать `newsModelBuilder` для построение модели
4. Создать представление на основании `/$Content/Templates/FullArticle.hbs`
5. Добавить в представление модель
6. Заменить все `{{какое-то-имя}}` в представлении на значения из модели
7. Удалить `Map`, который отвечает за отображение новости по-старому

Но есть несколько нюансов:
- Надо поправить конфигурацию путей на такую, чтобы определить параметр id:
```cs
endpoints.MapControllerRoute("default", "{controller=News}/{action=Index}/{id?}");
```
- Поле `ContentHtml` в модели содержит HTML, поэтому его нельзя рендерить с помощью `@`.
Вместо этого надо использовать хелпер: `@Html.Raw(content)` (название можно перевести как «сырой html»).
Этот хелпер не применяет html-кодирование к принимаемой строке.
- Пришло время победить исключение, которое возникает, если новость не найдена.
Добавь в метод контроллера в соответствующее место такой код:
```cs
if (model == null)
    return NotFound();
```

Это все инструкции по переделке страницы новостей. Можно переделывать!


### 3.3. Выделение общего кода

Сейчас в нескольких страницах используется одна и та же шапка страница, подключаются одни и те же скрипты.
Есть общий код, который хотелось бы выделить отдельно. Для этого в MVC предусмотрены Layout'ы (макеты).

Чтобы выделить общий код представлений `Index` и `FullArticle`, создай в папке `/Views/News` файл `_Layout.cshtml`.
В него скопируй содержимое любой из двух страниц. Удали директивы, начинающиеся с `@` из начала.
А затем замени то, что находится между `<!-- Body -->` и `<!--/ Body -->`, на вызов `@RenderBody()`.
Именно в `RenderBody` отрисуется представление, для которого будет установлен макет.

В обоих представлениях `Index` и `FullArticle` наоборот вырежи все вне `<!-- Body -->` и `<!--/ Body -->`,
но оставь директивы, начинающиеся с `@` в начале.
А еще добавь в начало подключение макета:
```cs
@{
    Layout = "_Layout";
}
```
Замечание. Содержимое нескольких `@{ ... }`, идущих подряд можно объединять — это ни на что не повлияет.

Проверь, что страницы новостей, несмотря на манипуляции выглядят как раньше.


Писать в каждом представлении имя макета, если оно для всех страниц одинаковое, тоже не хочется.
И в MVC есть возможность этого не делать — файл `_ViewStart.cshtml`.

Создай в папке `/Views/News` файл `_ViewStart.cshtml` и добавь в него следующее содержимое:
```cs
@using System.Globalization
@{
    ViewBag.Culture = CultureInfo.CreateSpecificCulture("ru-ru");
	Layout = "_Layout";
}
```

Соответственно, аналогичный код можно удалить из `Index.cshtml` и `FullArticle.cshtml`.
Нюанс здесь в том, что локальные переменные не передаются между отдельными view.
А вот специальный объект `ViewBag` передается между контроллером и всеми view. Поэтому в него можно положить `Culture`,
а затем достать в `Index.cshtml` и `FullArticle.cshtml`. Используй `ViewBag.Culture` вместо `culture`.
Примерно теми же свойствами, что и `ViewBag` обладает словарь `ViewData`. Им тоже можно было воспользоваться.

Проверь, что страницы новостей снова выглядят как раньше.


Следующий шаг — задать макет для всего сайта. Для этого надо перенести `_ViewStart.cshtml` в папку `Views`.
Тогда код из нее будет выполняться для всех view, в том числе в папке `/Views/Errors`.
А вот `_Layout.cshtml` надо перенести в папку `/Views/Shared`, потому что представления из этой папки
доступны во всех других папках, т.е. и для представлений из папки `/Views/News`, и из папки `/Views/Errors`.
Убедись, что после переносов для страниц новостей ничего не поменялось.

А вот для страниц ошибок — поменялось. Перейди по пути `/somepath` и убедись, что у страницы появился заголовок.
Надо его убрать. Для этого в начало `StatusCode.cshtml` добавь код, убирающий макет для страницы:
```cs
@{
    Layout = null;
}
```

На странице исключений для Production наоборот должно произойти задвоение заголовка страницы, ведь он там был.
В представлении `Exception` вырежи все вне `<!-- Body -->` и `<!--/ Body -->`, но оставь директиву `@model`.
Конечно, стоило бы проверить, что страница исключений продолжает работать как надо, но сейчас придется много перенастраивать,
поэтому не проверяй в этот раз.


### 3.4. Секции

На странице списка новостей надо добавить «важные новости».
Разметка для такой «важной новости» находится в файле `/$Content/Drafts/FeaturedArticles.html`.
Сами новости должны располагаться вверху страницы. Это место было помечено `<!-- Header /-->`,
а метка должна была сохраниться в `_Layout.cshtml`.

И вроде бы все, что надо сделать — пробежаться по массиву `Model.FeaturedArticles` с помощью `@foreach`,
ведь `newsModelBuilder.BuildIndexModel` корректно заполняет этот массив при передаче соответствующего параметра...
Но нюанс в том, что этот `@foreach` должен вызываться в `_Layout.cshtml`, где модель конкретной страницы недоступна.

Короче, нужны секции. Секция — это некоторая метка, которая ставится в макете,
а конкретное представление может определить разметку для этой метки.

Что нужно сделать конкретно:
1. При вызове `newsModelBuilder.BuildIndexModel` в `NewsController` вторым параметром передавай `true`
2. Замени в `_Layout.cshtml` метку `<!-- Header /-->` на `@RenderSection("Header", false)`
3. Добавь в `Index.cshtml` в начало или в конец следующий код:
```cs
@section Header
{    
}
```
4. Добавь внутрь разметку из `/$Content/Drafts/FeaturedArticles.html`
5. Сделай так, чтобы внутри показывались новости из `Model.FeaturedArticles`


### 3.5. Хелперы для ссылок

Сейчас, когда все страницы отображаются с помощью контроллеров, можно изменить способ генерации адресов в ссылках.
Т.е. вместо явного задания href использовать tag-хелпер для тега `<a>`.


Чтобы пользоваться tag-хелперам их необходимо подключить.
Чтобы подключить сразу для всех страниц, добавь в папку `/Views` файл `_ViewImports.cshtml` с таким содержимым:
```cs
@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
```

`_ViewImports.cshtml` — специальный тип файлов, который позволяет добавлять директивы `@using` и `@addTagHelper`
для всех представлений в папке, тогда как обычно эти директивы действуют в рамках одного файла.


А теперь можно заменять обычные ссылки на tag-хелперы.

Сначала сделай это для ссылок на страницу новости, т.е. вместо `href` пропиши следующие атрибуты:
- `asp-controller` с именем контроллера, но без суффикса `Controller`
- `asp-action` с именем метода
- `asp-route-id` с идентификатором новости (через атрибуты с префиксом `asp-route-` передаются параметры метода)

Убедись, что ссылки работают.


Далее сделай это для ссылок «Новее» и «Старше», т.е. вместо `href` пропиши следующие атрибуты:
- `asp-controller` с именем контроллера, но без суффикса `Controller`
- `asp-route-pageIndex` с индексом страницы

А, чтобы пользователь не кликал лишний раз, когда уже находится на первой или последней странице,
при условии `Model.IsFirst` показывай заблокированную версию ссылки «Новее»,
а при условии `Model.IsLast` — заблокированную версию ссылки «Старше».
Эти варианты ссылок уже есть на странице в комментариях.
Подсказка: используй `@if {} else {}`.


## 4. Форма создания новостей

Теперь пришло время добавить возможность добавления новых новостей.


## 4.1. Отправка данных формы

Для этого нужно создать страницу с формой, в которой можно  будет задать все поля новости
и сохранить результат. Странца должна открываться по адресу `/editor`, ссылок на сайте на нее не будет.

Вот заготовочка для контроллера:
```cs
using System;
using BadNews.Models.Editor;
using BadNews.Repositories.News;
using Microsoft.AspNetCore.Mvc;

namespace BadNews
{
    public class EditorController : Controller
    {
        private readonly INewsRepository newsRepository;

        public EditorController(INewsRepository newsRepository)
        {
            this.newsRepository = newsRepository;
        }

        public IActionResult Index()
        {
            return View(new IndexViewModel());
        }
    }
}

```
Сделай с ее помощью контроллер.

Модель для создания новости уже добавлена в проект по пути `/Models/Editor/IndexModel`.
В ней с помощью атрибутов сразу прописаны правила валидации. Посмотри, что она из себя представляет.

В `/$Content/Drafts/Editor.html` находится разметка для страницы добавления новости. Сделай из нее view.

Приготовления закончены. Зайди на страницу `/editor` и убедись, что открылась форма для добавления новости.


Теперь надо сделать так, чтобы данные формы отправлялись на сервер.

Для начала добавь заглушку метода, на который форма будет отправлять данные:
```cs
[HttpPost]
public IActionResult CreateArticle([FromForm] IndexViewModel model)
{
    return View("Index", model);
}
```
При отправке формы, данные отправляются в теле запроса в специальном формате `application/x-www-form-urlencoded`.
Атрибут [FromForm] позволяет получить из тела эти данные в виде объекта.

Обычно, чтобы форма что-то куда-то отправляла ей надо задать атрибуты `action` и `method`.
Но благодаря tag-хелперу `<form>`, можно сделать это иначе.
Добавь в тег `<form>` два атрибута:
```cs
<form asp-controller="Editor" asp-action="CreateArticle"
```
и форма будет отправляться по кнопке «Отправить».

Но для заполнения модели этого не достаточно, ведь неизвестно каким полям модели соответствуют текстовые поля формы.
Здесь опять помогут tag-хелперы. В первом текстовом поле (это `input`) добавь атрибут `asp-for` со значением `Header`.
В двух других (это `textarea`) также добавь атрибут `asp-for`, но уже со значениями `Teaser` и `ContentHtml`.

Теперь проверь форму. Для этого в каждое из текстовых полей добавь как-то текст и нажми отправить.
В результате страница должна перезагрузиться, ведь `CreateArticle` вновь показывает страницу с формой.
Но при этом текст в полях должен сохраниться,
т.к. данные из формы преобразуются в модель (`[FromForm] IndexViewModel model`),
а затем по модели строится страница с формой (`return View("Index", model)`).


Данные формы в контроллер приходят, значит осталось их просто корректно обработать.

В `IndexModel` с помощью атрибутов заданы правила проверки. Проверка модели по этим атрибутам будет происходить
до передачи модели в метод контроллера, а все ошибки окажутся в свойстве `ModelState` контроллера.
Проверить есть ли ошибки можно с помощью свойства `ModelState.IsValid`.

Если ошибки есть, то автору надо вернуть статью на доработку вот так:
```cs
if (!ModelState.IsValid)
    return View("Index", model);
```

Если ошибок нет, то надо создать новый `NewsArticle` по данным формы, сохранить его
и отправить автора на страницу только что добавленной новости:
```cs
var id = newsRepository.CreateArticle(new NewsArticle {
    Date = DateTime.Now.Date,
    Header = model.Header,
    Teaser = model.Teaser,
    ContentHtml = model.ContentHtml,
});

return RedirectToAction("FullArticle", "News", new {
    id = id
});
```

Добавь этот код и убедись, что новость с непустым заголовком создается, а страница с ней показывается.


## 4.2. Валидация данных формы

Форма работает, но есть проблема. Если данные формы заполнены некорректно: не задан заголовок статьи,
либо в тизере или содержимом статьи реально без обмана используется действительно одно из стоп-слов,
то автору не показываются сообщения об этих ошибках. А должны бы.

Чтобы сообщения об ошибках добавлялись в представление, достаточно использовать tag-хелпер `asp-validation-for`.
Таким атрибутом нужно отметить некоторый тег, а в качестве значения указать имя поля модели.
После этого все сообщения об ошибках, связанные с этим полем, будут добавляться к помеченному тегу.

В разметки страницы с формой для отображения ошибок предусмотрены такие теги: `<span class="text-danger"></span>`.
Пометь их атрибутом `asp-validation-for` с одним из значений `Header`, `Teaser` и `ContentHtml`.

Теперь убедись, что если попытаться создать новость с пустым заголовком, словом «действительно» в тизере
и словом «реально» в статье, то с сервера вернется 3 сообщения об ошибке и каждое отобразится в своем месте.


Но хочется большего. Хочется, чтобы сообщения об ошибках появлялись не после отправки формы,
а сразу после редактирования любого из полей формы. Другими словами, проверки должны работать в браузере.

Для этого потребуются некоторые библиотеки на JavaScript:
- `jquery.validate` — стандартная библиотека валидаций для jQuery
- `jquery.validate.unobtrusive` — расширение библиотеки валидаций от Microsoft,
чтобы проверять значения форм «unobtrusive», т.е. «ненавязчиво» и на стороне браузера

Подключи эти скрипты с помощью с помощью отдельного partial view.
1. Создай файл `/Views/Shared/_ValidationScriptsPartial.cshtml` и заполни так:
```html
<script src="/lib/jquery-validation/dist/jquery.validate.min.js"></script>
<script src="/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.min.js"></script>
```
2. Подключи partial view в `_Layout.cshtml` после всех тегов `<script>` так:
```cs
<partial name="_ValidationScriptsPartial" />
```

После подключения этих скриптов перейди на страницу добавления новости, введи в заголовке что-нибудь,
а затем сотри — появится сообщение об ошибке. Все уже работает, потому что для проверки поля `Header`
используется встроенный атрибут `Required`. Для того, чтобы написанная для этого сайта проверка `StopWords`
начала работать в браузере, надо приложить дополнительные усилия.


Как же добавить свою собственную проверку для модели, чтобы она работала и на сервере и на клиенте?
1. Надо создать на C# атрибут проверки `StopWordsAttribute`. С его помощью можно отмечать свойства модели,
которые должны проверяться этой проверкой. А также в нем можно реализовать метод `IsValid`,
который как раз и будет осуществлять проверку.
Посмотри как это сделано в файле `/Validation/StopWordsAttribute.cs`.
2. Надо написать код проверки на JS, аналогичный коду на C#, и подключить скрипт с этим кодом.
Посмотри как это сделано в файле `/wwwroot/js/validation.js`.
3. Надо добавить на на C# класс `StopWordsAttributeAdapter`, который будет добавлять к тегам полей формы информацию,
необходимую для работы проверки на JS.
Посмотри как это сделано в файле `/Validation/StopWordsAttributeAdapter.cs`.
4. Надо добавить класс `StopWordsAttributeAdapterProvider`, который будет связывать `StopWordsAttribute`
и `StopWordsAttributeAdapter`.
Посмотри как это сделано в файле `/Validation/StopWordsAttributeAdapterProvider.cs`.
5. Зарегистрировать класс `StopWordsAttributeAdapterProvider` в DI-контейнере в методе `ConfigureServices`.

Из всего перечисленного осталось сделать немного.
Во-первых, добавь регистрацию провайдера в метод `ConfigureServices`:
```cs
services.AddSingleton<IValidationAttributeAdapterProvider, StopWordsAttributeAdapterProvider>();
```
Во-вторых, подключи скрипт с кодом проверки в `_ValidationPartial.cshtml`
```html
<script src="/js/validation.js"></script>
```

Теперь перейди на страницу добавления новости и напиши слово «действительно» в тизер или текст статьи.
После того, как ты переведешь фокус в другое поле, должно появиться сообщение, что нельзя использовать стоп-слова.


### Компоненты

Когда на странице много разных элементов с разными данными, не очень удобно строить одну большую модель,
а затем в большом представлении распределять эти данные по нужным местам.
Надо как-то декомпозировать задачу на более маленькие. Компонентный подход позволяет это сделать.

Компонент — это элемент страницы с собственным методом `Invoke` или `InvokeAsync`, который строит модель компонента,
а также собственное представление, которое эту модель отрисовывает.

Использование компонентов позволяет не только упростить конкретную страницу, но и легко переиспользовать
выделенный компонент на других страницах.


## 5.1. Архив новостей

Необходимо добавить новый функционал — архив новостей.
Архив новостей должен показывать ссылки на новости по годам, а при переходе по ссылке за конкретный год
в списке новостей должны остаться только новости за этот год.


Сделай список ссылок на новости разных лет в виде компонента.

Создай файл `/Components/ArchiveLinksViewComponent.cs` с таким содержимым:
```cs
using BadNews.Repositories.News;
using Microsoft.AspNetCore.Mvc;

namespace BadNews.Components
{
    public class ArchiveLinksViewComponent : ViewComponent
    {
        private readonly INewsRepository newsRepository;

        public ArchiveLinksViewComponent(INewsRepository newsRepository)
        {
            this.newsRepository = newsRepository;
        }

        public IViewComponentResult Invoke()
        {
            var years = newsRepository.GetYearsWithArticles();
            return View(years);
        }
    }
}
```

Создай представление `/Views/Shared/Components/ArchiveLinks/Default.cshtml`
с содержимым из заготовки `/$Content/Drafts/ArchiveLinks.html`.
Да, путь до представления именно такой
- `Shared` намекает, что для всех контроллеров компонент будет выглядеть одинаково
- `Components/ArchiveLinks` — без комментариев
- `Default.cshtml` задает представление по-умолчанию, ведь у компонента может быть несколько

Добавь в представления `/Views/News/Index.cshtml` и `/Views/News/FullArticle.cshtml`
в тег `<aside>` подключение компонента:
```cs
<vc:archive-links></vc:archive-links>
```
Такое подключение компонента использует стиль tag-хелперов, поэтому добавь такую строчку в `_ViewImports.cshtml`:
```cs
@addTagHelper *, BadNews
```
Она обеспечит подключение tag-хелперов, определенных в проекте `BadNews`.

Убедись, что статический список ссылок на новости появляется на странице списка новостей и странице новости.


Чтобы ссылки в архиве работали надо доработать страницу списка новостей:
она должна получать и использовать параметр `year` их query string.
1. Добавь аргумент `int? year` в метода `Index` в `NewsController`
2. Прокинь это аргумент в вызов метода `BuildIndexModel` и сделай так, чтобы «важные новости»
`BuildIndexModel` строил только тогда, когда `year` не задан.
3. В `/Views/News/Index.cshtml` поправь ссылки «Новее» и «Старше»: в них должен передаваться год
аналогично `pageIndex`, а текущее значение года можно взять из модели `Model.Year`.
4. Убедись, что по пути `/news?year={текущий-год}` открывается список новостей с одной новостью «Настал Новый год!»,
а «важные новости» не показываются.


Теперь осталось доработать представление компонента, т.е. `/Views/Shared/Components/ArchiveLinks/Default.cshtml`.
1. В качестве модели используй `IList<int>`, ведь компонент передает в представление список лет
2. Используй свои знания Razor и tag-хелперов, чтобы оживить страницу.
При этом добейся того, чтобы в коде остался только один тег `<a>`.
Подсказка: если обернуть некоторое значение в тег `<text>`, то Razor будет воспринимать его как разметку, а не как код,
но сам тег `<text>` на страницу не добавит.


## 5.2. Случайная погода

Надо создать еще один компонент. На этот раз для отображения погоды.


Буду краток:
1. Для определенности пусть компонент называется `WeatherViewComponent`.
2. Данные можно получить методом `GetWeatherForecastAsync` из `IWeatherForecastRepository`.
Этот интерфейс реализуется классом `WeatherForecastRepository`. Не забудь зарегистрировать в `ConfigureServices`.
3. Разметку можно взять в `/$Content/Drafts/Weather.html`.
4. Образец компонента — `ArchiveLinksViewComponent`. Но тебе понадобится асинхронный вариант `Invoke`:
```cs
public async Task<IViewComponentResult> InvokeAsync()
{
}
```
5. В представлениях можно объявлять методы. Пожалуй этот тебе пригодится:
```cs
@{
    string FormatTermperature(int temperature) => temperature > 0 ? $"+{temperature}" : temperature.ToString();
}
```
6. Размести этот компонент в боковой части страницы списка новостей и страницы новости над компонентом «Архив новостей»

На этом все. Сделай компонент для отображения погоды.


## 5.3. Погода из открытых источников

Надо научиться получать реальную погоду в Екатеринбурге, а не показывать случайное значение температуры.


Дело за малым — подключить готовый `OpenWeatherClient` к `WeatherForecastRepository`.
Но, чтобы `OpenWeatherClient` работал, ему надо передать секретный ApiKey.
Хранить такой ApiKey можно только в настройках, причем таких, в которые в системе контроля версий не хранятся.

Создай файл `/appsettings.Secret.json` и заполни так:
```json
{
  "OpenWeather": {
    "ApiKey": "58cb7c533322b79c68aa0908f5bbbd0b"
  }
}
```
`.gitignore` настроен игнорировать файлы с окончанием `.Secret.json`,
поэтому ты не сможешь ApiKey случайно закоммитить.

Теперь настройки из этого файла надо зачитать в `IConfiguration`.
Для этого добавь такой вызов в цепочку вызовов в методе `CreateHostBuilder` в файле `Program.cs`:
```cs
.ConfigureHostConfiguration(config => {
    config.AddJsonFile("appsettings.Secret.json", optional: true, reloadOnChange: false);
})
```

Следующий шаг — передать полученные настройки в `WeatherForecastRepository`.
Идея, лежащая на поверхности, добавить в конструктор `WeatherForecastRepository`
параметр `IConfiguration configuration`, а затем из этой конфигурации зачитать нужные настройки.

Но эта идея не самая лучшая, потому что при перемещении настроек из одной части `IConfiguration`
заставит менять код `WeatherForecastRepository`. Да и в модульных тестах на `WeatherForecastRepository`
не очень удобно заполнять `IConfiguration`.

Есть способ лучше — использовать `IOptions`. Для этого:
1. Настрой заполнение опций для погоды по секции `OpenWeather` конфигурации,
добавив в метод `ConfigureServices` в `Startup` такую строчку:
```cs
services.Configure<OpenWeatherOptions>(configuration.GetSection("OpenWeather"));
```
2. Добавь параметр `IOptions<OpenWeatherOptions> weatherOptions` в конструктор `WeatherForecastRepository`.
3. Достань необходимое значение вот так: `weatherOptions?.Value.ApiKey`
4. Profit!


После прокидывания ApiKey до `WeatherForecastRepository` осталось совсем немного:
- Начни получать погоду в методе `GetWeatherForecastAsync` через `OpenWeatherClient`
- Чтобы перейти от формата, в котором данные получает `OpenWeatherClient` к формату `WeatherForecast`,
который надо вернуть, используй статический метод `WeatherForecast.CreateFrom`.
- Если по каким-то причинам `OpenWeatherClient` не отдает данные о погоде — используй рандомный генератор погоды!

Как закончишь, убедись, что теперь компонент показывает правильную погоду.
